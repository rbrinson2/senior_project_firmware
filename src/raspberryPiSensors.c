/*
 * Note: this file originally auto-generated by mib2c
 * using mib2c.scalar.conf
 */

#include "ina260.h"
#include "raspberryPiSensors.h"
#include <linux/kernel.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <sys/sysinfo.h>

int current = 0;
int voltage = 0;
int power = 0;
char addr[] = "0x40";
char desc[] = "Ina260 sensor";
int lastUpdate = 0;
int sensorStatus = 0;
int errorCount = 0;
long upTime = 0;
struct sysinfo s_info;

/** Initializes the raspberryPiSensors module */
void init_raspberryPiSensors(void) {
    const oid sensorCurrent_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 1, 1};
    const oid sensorVoltage_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 1, 2};
    const oid sensorPower_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 1, 3};
    const oid sensorDescription_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 1, 4};
    const oid sensorAddress_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 1, 5};
    const oid sensorLastUpdate_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 1, 6};
    const oid sensorOperationalStatus_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 2, 1};
    const oid sensorErrorCount_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 2, 2};
    const oid sensorUptime_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 2, 3};
    const oid gpuPowerLimit_oid[] = {1, 3, 6, 1, 4, 1, 75, 1, 3, 1};

    DEBUGMSGTL(("raspberryPiSensors", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "sensorCurrent", handle_sensorCurrent, sensorCurrent_oid,
        OID_LENGTH(sensorCurrent_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "sensorVoltage", handle_sensorVoltage, sensorVoltage_oid,
        OID_LENGTH(sensorVoltage_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "sensorPower", handle_sensorPower, sensorPower_oid,
        OID_LENGTH(sensorPower_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "sensorDescription", handle_sensorDescription, sensorDescription_oid,
        OID_LENGTH(sensorDescription_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "sensorAddress", handle_sensorAddress, sensorAddress_oid,
        OID_LENGTH(sensorAddress_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "sensorLastUpdate", handle_sensorLastUpdate, sensorLastUpdate_oid,
        OID_LENGTH(sensorLastUpdate_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "sensorOperationalStatus", handle_sensorOperationalStatus,
        sensorOperationalStatus_oid, OID_LENGTH(sensorOperationalStatus_oid),
        HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "sensorErrorCount", handle_sensorErrorCount, sensorErrorCount_oid,
        OID_LENGTH(sensorErrorCount_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "sensorUptime", handle_sensorUptime, sensorUptime_oid,
        OID_LENGTH(sensorUptime_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration(
        "gpuPowerLimit", handle_gpuPowerLimit, gpuPowerLimit_oid,
        OID_LENGTH(gpuPowerLimit_oid), HANDLER_CAN_RWRITE));
}

int handle_sensorCurrent(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests) {
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    current = (int)getCurrent();

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, &current,
                                 sizeof(current));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sensorCurrent\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int handle_sensorVoltage(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests) {
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    int voltage = (int)getVoltage();
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, &voltage,
                                 sizeof(voltage));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sensorVoltage\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int handle_sensorPower(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info *reqinfo,
                       netsnmp_request_info *requests) {
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    power = (int)getPower();
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, &power,
                                 sizeof(power));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sensorPower\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int handle_sensorDescription(netsnmp_mib_handler *handler,
                             netsnmp_handler_registration *reginfo,
                             netsnmp_agent_request_info *reqinfo,
                             netsnmp_request_info *requests) {
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, desc,
                                 sizeof(desc));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sensorDescription\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int handle_sensorAddress(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests) {
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, addr,
                                 sizeof(addr));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sensorAddress\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int handle_sensorLastUpdate(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests) {
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, &lastUpdate,
                                 sizeof(lastUpdate));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sensorLastUpdate\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int handle_sensorOperationalStatus(netsnmp_mib_handler *handler,
                                   netsnmp_handler_registration *reginfo,
                                   netsnmp_agent_request_info *reqinfo,
                                   netsnmp_request_info *requests) {
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 &sensorStatus, sizeof(sensorStatus));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR,
                 "unknown mode (%d) in handle_sensorOperationalStatus\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int handle_sensorErrorCount(netsnmp_mib_handler *handler,
                            netsnmp_handler_registration *reginfo,
                            netsnmp_agent_request_info *reqinfo,
                            netsnmp_request_info *requests) {
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_COUNTER, &errorCount,
                                 sizeof(errorCount));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sensorErrorCount\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int handle_sensorUptime(netsnmp_mib_handler *handler,
                        netsnmp_handler_registration *reginfo,
                        netsnmp_agent_request_info *reqinfo,
                        netsnmp_request_info *requests) {
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    sysinfo(&s_info);
    upTime = s_info.uptime;
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, &upTime,
                                 sizeof(upTime));
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_sensorUptime\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int handle_gpuPowerLimit(netsnmp_mib_handler *handler,
                         netsnmp_handler_registration *reginfo,
                         netsnmp_agent_request_info *reqinfo,
                         netsnmp_request_info *requests) {
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_UINTEGER,
                                 /* XXX: a pointer to the scalar's data */,
                                 /* XXX: the length of the data in bytes */);
        break;

    /*
     * SET REQUEST
     *
     * multiple states in the transaction.  See:
     * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
     */
    case MODE_SET_RESERVE1:
        /* or you could use netsnmp_check_vb_type_and_size instead */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_UINTEGER);
        if (ret != SNMP_ERR_NOERROR) {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:
        /* XXX malloc "undo" storage buffer */
        if (/* XXX if malloc, or whatever, failed: */) {
            netsnmp_set_request_error(reqinfo, requests,
                                      SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:
        /* XXX: free resources allocated in RESERVE1 and/or
           RESERVE2.  Something failed somewhere, and the states
           below won't be called. */
        break;

    case MODE_SET_ACTION:
        /* XXX: perform the value change here */
        if (/* XXX: error? */) {
            netsnmp_set_request_error(reqinfo, requests, /* some error */);
        }
        break;

    case MODE_SET_COMMIT:
        /* XXX: delete temporary storage */
        if (/* XXX: error? */) {
            /* try _really_really_ hard to never get to this point */
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /* XXX: UNDO and return to previous value for the object */
        if (/* XXX: error? */) {
            /* try _really_really_ hard to never get to this point */
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_gpuPowerLimit\n",
                 reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
